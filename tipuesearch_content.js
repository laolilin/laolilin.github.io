var tipuesearch = {"pages":[{"title":"关于我","text":"何许人也？","tags":"pages","url":"//blog.laolilin.com/pages/about.html","loc":"//blog.laolilin.com/pages/about.html"},{"title":"Raspberry pi 4 和 Cm4 aarch64 配置","text":"前言 Raspberry Pi 4 和 Raspberry Pi Compute Module(CM4) 具备BCM2711 1.5GHz 4 核心 64-bit ARM Cortex-A72 CPU，Rpi4我用的是8GB内存，CM4是8GB无线+32GB EMMC的版本。 64位系统的安装比较麻烦，此处特记录。 系统安装 系统我选 Archlinux ，与之前的树莓派一致。 具体安装方法 Archlinux ARM 安装指引 进行安装，很简单，不赘述。默认用户名 alarm ，密码同用户名。敢死队长 root 密码为 root 。 运行前配置 ** 以下不注明的都是在 Raspberry Pi 4 上进行操作 ** 安装TF卡前，根据 Archlinux ARM 安装指引_ 首次安装后要执行 sed -i 's/mmcblk0/mmcblk1/g' root/etc/fstab 替换启动盘。 Raspberry Pi 4 有时候在不插HDMI的时候无法启动，为防止不能启动，HDMI配置为热插拔： echo hdmi_force_hotplug=1 >> boot/config.txt 开启串口： echo enable_uart=1 >> boot/config.txt 安装TF卡，启动、插上网线并使用串口登录 root 修改软件源 /etc/pacman.d/mirrorlist 加入 Server = https://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repo 替换`Raspberry Pi 4`专用内核 默认的内核是 linux-aarch64 ，目前无法在 CM4 上顺利启动，我们需要替换为 专用内核 。 pacman -Syyu linux-raspberrypi4 raspberrypi-firmware 安装完毕后将 /etc/fstab 为 /dev/mmcblk0p1 。 暂不重启 启动设置 开启 ssh touch /boot/ssh 其他启动设置 为防止不能启动，修改 /boot/cmdline.txt 删除 kgdboc=ttyAMA0,115200 在 /boot/cmdline.txt 修改 rw 为 ro ，即只读模式 。 同样，在 /etc/fstab 中也需要将boot分区变为ro defaults,ro,errors=remount-ro 重启进入系统，以 `root` 登录 无线设置 目前系统默认找不到无线网卡，需要运行 rmmod brcmfmac && modprobe brcmfmac 加载无线网卡驱动。 对于 `CM4` 需要将驱动改名： cd /lib/firmware/brcm cp 'brcmfmac43455-sdio.Raspberry Pi Foundation-Raspberry Pi Compute Module 4.txt' 'brcmfmac43455-sdio.raspberrypi,4-compute-module.txt' rmmod brcmfmac && modprobe brcmfmac 其他设置 安装一些基本软件 pacman -S sudo tmux ufw 启用 sshd systemctl enable sshd ； 修改用户名 按个人习惯，先改掉默认的用户名。 如果你直接用alarm登录，是无法修改用户名的，先用 root 登录。 new_user = YOURNAME # change user name usermod -l $new_user -d /home/ $new_user -m alarm # chenge user group groupmod -n $new_user alarm 修改用户密码 passwd $new_user 。 sudo 配置 visudo # uncomment the line \"%wheel ALL=(ALL) ALL\" vi /etc/locale.gen # uncomment en_US.UTF-8 UTF-8 locale-gen 时间设置 timedatectl set-ntp true rm /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 配置完成，现在可以重启并 `ssh` 进入系统了 CM4系统安装 将 Raspberry Pi 4 的上述系统，复制到 CM4 的 TF 卡或EMMC中，就可以完成配置。","tags":"Tech","url":"//blog.laolilin.com/posts/2021/05/config_raspberry_pi4_and_cm4_aarch64.html","loc":"//blog.laolilin.com/posts/2021/05/config_raspberry_pi4_and_cm4_aarch64.html"},{"title":"用 Docker 编译 Openwrt","text":"前言 家里的 斐讯 K2P 路由器已经使用了3年了，一直用别人的固件，后来想自己编译固件。 我打算编译和使用 Lean's OpenWrt ，Lean 的这个固件非常完善，对 K2P 的无线支持的非常好（开源的 Openwrt K2P 的无线没办法 2.4G 和 5G 同时使用）。 采用 Docker 进行编译有很多好处，避免在宿主机上安装杂七杂八的软件。网上有许多 lede-builder ，我尝试过使用 hanxi的lede-docker-builder ，用了几天，发现有一些问题： Docker 底包用的是 Ubuntu 18.04 ，里面的包都比较老了，尤其是 Openwrt 19.07 发布之后，有些需要 Python 3.5 以上版本的包都没办法编译； 镜像文件比较大，解压之后足足有 1.82G 下载下来非常慢。 折腾了一天，我终于把设置和流程弄好了。 建立 Docker 镜像 我在 github 上新建了一个仓库 lll9p/docker-lede-builder ，要点主要有： 使用 debian:buster-slim 容器，比较新，而且比完整的 debian:buster 有所精简； 预安装 proxychains4 和 sudo proxychains 当处于网络环境不好的时候使用代理进行文件下载或提高网速； sudo 可以进行一些 root 用户操作； 使用 apt-get --no-install-recommends 命令进行安装，大幅精简镜像体积； 新建 build 用户，免于直接使用 root 编译。 Dockerfile 如下： FROM debian:buster-slim MAINTAINER lll9p <lll9p.china@gmail.com> ARG DEBIAN_FRONTEND = noninteractive RUN apt-get update \\ && apt-get install -y locales curl wget \\ && apt-get install -y --no-install-recommends build-essential \\ asciidoc binutils bzip2 gawk gettext git libncurses5-dev \\ libz-dev patch python3 unzip zlib1g-dev lib32gcc1 \\ libc6-dev-i386 subversion flex uglifyjs git-core \\ gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo \\ libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf \\ automake libtool autopoint device-tree-compiler \\ proxychains4 sudo vim \\ && groupadd -r build && useradd -r -u 1000 -g build build \\ && passwd -d root \\ && passwd -d build \\ && echo '%build ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* \\ && localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8 ENV LANG en_US.utf8 USER build WORKDIR /home/build ENV FORCE_UNSAFE_CONFIGURE = 1 CMD [ \"/bin/bash\" ] push 到 github 上之后，再在 Docker 上新建一个 repo : lll9p/docker-lede-builder@dockerhub ，在 Build configurations 那里设置好指向就自动进行 build 了，经过几次修改提交之后，最后一个 build 用了11min的样子。 pull 镜像下来，大小也才 650MB ，精简的不错。 一些编译辅助脚本 利用脚本可以方便地编译或实现自动化： 目录结构初始化 - 将 /home/\\`whoami\\`/data/docker 挂载到 docker 的启动目录 /home/build 。 data/docker 目录下 git clone Lean's OpenWrt 。 由于我使用了 server酱 ，顺便也 git 一份到 docker 下。 脚本: comple.sh 该脚本作用是 进行 proxychans 设置（需要提前在宿主机上开启代理） 更新 lede 和 server酱 更新 feeds 由于在之前使用 data/docker/lede/scripts/diffconfig.sh > data/diffconfig 所以可以用它来更新 .config ，不必每次都 make menuconfig 了 最后是 download 和 make 编译，采用 5 个进程 如果不希望使用代理进行下载，可以将 PROXYCHAINS 注释掉 #!/bin/bash BUILD_PATH = \"/home/build\" PROXYCHAINS = \"proxychains4 -q \" echo 'Start build script.' echo '' echo '--- Modify proxychains configs. ---' sudo sed -i '$ d' /etc/proxychains4.conf sudo sed -i '$ d' /etc/proxychains4.conf echo 'socks5 172.17.0.1 1081' | sudo tee -a /etc/proxychains4.conf echo '' | sudo tee -a /etc/proxychains4.conf echo '--- Pull from git server. ---' echo '' echo '--- Pull from lede. ---' cd ${ BUILD_PATH } /lede ${ PROXYCHAINS } git pull echo '--- Pull from luci-app-serverchan. ---' cd ${ BUILD_PATH } /luci-app-serverchan ${ PROXYCHAINS } git pull echo '' echo '--- Add luci-app-serverchan to package. ---' echo '' cd ${ BUILD_PATH } /lede rm ${ BUILD_PATH } /lede/package/feeds/luci/luci-app-serverchan ln -s ${ BUILD_PATH } /luci-app-serverchan ${ BUILD_PATH } /lede/package/feeds/luci/luci-app-serverchan ${ PROXYCHAINS } ${ BUILD_PATH } /lede/scripts/feeds update -a && ${ BUILD_PATH } /lede/scripts/feeds install -a echo '--- Remove tmp files. ---' rm -rf ${ BUILD_PATH } /lede/tmp echo '--- Remove tmp old config. ---' rm -rf ${ BUILD_PATH } /lede/.config echo '--- Using diff config file. ---' cp ${ BUILD_PATH } /diffconfig ${ BUILD_PATH } /lede/.config echo '--- Expand to full config file. ---' make defconfig echo '--- Download needed files. ---' ${ PROXYCHAINS } make download echo '--- Start build. ---' make -j5 V = s flash.sh 用于自动更新编译好的固件，具体目录和 Openwrt 的密码请自行更换，依赖 sshpass 。 #! /bin/bash sshpass -p 我的密码 ssh root@192.168.1.1 'rm /tmp/update.bin' sshpass -p 我的密码 scp /home/u/data/docker/lede/bin/targets/ramips/mt7621/openwrt-ramips-mt7621-phicomm_k2p-squashfs-sysupgrade.bin root@192.168.1.1:/tmp/update.bin sshpass -p 我的密码 ssh root@192.168.1.1 'sysupgrade -v /tmp/update.bin' 使用方法 启动 docker 先使用 sudo systemctl start docker 启动 docker daemon ，然后将 lede 克隆到 data/docker 目录下； 再执行 sudo docker pull lll9p/docker-lede-builder 安装所需镜像； 执行 sudo docker run --rm -it -v /home/u/data/docker:/home/build lll9p/docker-lede-builder 即可进入编译环境，可以进行手动编译或者使用之前提供的 compile.sh 脚本进行自动编译； 可以使用 sudo docker run --rm=true -v /home/lao/data/docker:/home/build lll9p/docker-lede-builder /bin/bash /home/build/compile.sh 进行自动编译。","tags":"Tech","url":"//blog.laolilin.com/posts/2020/02/using_docker_to_build_openwrt.html","loc":"//blog.laolilin.com/posts/2020/02/using_docker_to_build_openwrt.html"},{"title":"Python实现单形重心法混料设计","text":"介绍及概念 单纯形重心设计法是一种效率较高的混料试验统计模型，可用来设计试验，它能根据试验点和响应值给出响应曲面（模型）。 该法具有较高的精度和可靠性，以及较少的试验量，很适合混料试验设计。 概念 单形（单纯形）：为空间中顶点比维数多1的凸多边形，比如〇维的点、一维的线段，二维的三角形、三维的四面体等。 响应值：某一试验点试验后的评价。 三角坐标系：由三角形构成的坐标系，顶点代表对应成分的最大值。特点是三角形内（含边）一点 \\(P(ax,by,cz)\\) ，过P作三条对三角形边的平行线，可以确定x,y,z的比例。如图所示。 等值线：将某一指标中数值相同的点连线。等值线实际上是将空间（Z轴）投影到平面（XY轴）的表示。如下图。 单形格子设计 设试验中考察的指标为 \\(y\\) ，那么 \\(y\\) 与 \\(p\\) 个因子 \\(x_1,x_2,...,x_p\\) 的关系可以表示为： \\(y=f(x_1,x_2,\\dot,x_p )+\\varepsilon\\) 其中， \\(\\varepsilon\\) 是随机误差，且要保证 \\(0\\leq x\\leq 1 ,\\sum_{i=1}&#94;p x_i=1\\) 称 \\(y=f(x_1,x_2,\\dots,x_p)\\) 为响应函数，当响应函数中的未知参数用估计值代替后便得到回归方程，也称响应曲面方程。 由于 \\(f(x_1,x_2,...,x_p)\\) 形式往往是未知的，通常用 \\(x_1,x_2,\\dots,x_p\\) 的一个 \\(d\\) 次多项式表示，此时一个混料试验由因子数 \\(p\\) 与响应多项式的次数 \\(d\\) 来确定，以后用 \\(M\\{p,d\\}\\) 表示一个混料试验。 即 ：（公式1） \\begin{align*} y&=f(x_1,x_2,\\dots,x_p) \\\\ &=\\sum_{i=1}&#94;p\\eta_ix_i+\\sum_{i\\leq j}\\eta_{ij}x_ix_j+\\sum_{i\\leq j\\leq k}\\eta_{ijk}x_ix_jx_k+\\cdots \\end{align*} 单形格子设计是 Scheffé 提出的一种混料设计。 \\(M\\{p,d\\}\\) 的单形格子设计，为 \\(d\\) 阶格子设计，它将单形的边划分成 \\(d\\) 等份，在等分点做与其它边平行的直线，形成许多格子，故名单形格子设计。 \\(p=1\\) ，为点； \\(p=2\\) ，为线段； \\(p=3\\) ，为三角形； \\(p=4\\) ，为四面体； \\(p=5\\) ，为超四面体…… 举例： \\(p=3\\) ，一阶、二阶和三阶单形格子设计的点分布图。 单形重心设计 单形格子设计的缺陷是在 \\(M\\{p,d\\}\\) 单形格子设计中，当 \\(d>2\\) 时某些混料设计中格子点的非零坐标（如 \\(M\\{3,3\\}\\) 中的8、9及其对称点）并不相等，这种非对称性会使某些点对回归系数的估计产生较大的影响，为改进这一点， Scheffé 提出了一种只考虑有相等非零坐标的单形重心设计，既消除了以上缺陷，又不至于试验点数太多。 单形重心设计 [1] 的试验点为 \\(1\\) 到 \\(p\\) 个顶点的重心，顶点本身就是重心，两个顶点的重心是它们连线的中点，三个顶点的重心是它们组成正三角形的中心，……， \\(p\\) 个顶点的重心就是该单形的中心。 此时给出的多项式模型称为 Scheffé单形重心设计的多项式模型 。具体如下，注意最后一项。（公式2） \\begin{align*} y&=f(x_1,x_2,\\cdots,x_p) \\\\ &=\\sum_{i=1}&#94;p\\eta_ix_i+\\sum_{i\\leq j}\\eta_{ij}x_ix_j+\\sum_{i\\leq j\\leq k}\\eta_{ijk}x_ix_jx_k+\\cdots+\\eta_{12\\cdots p}x_1x_2\\cdots x_p \\end{align*} 其中，若 \\(p=3\\) ，由于只取重心试验，故有： \\begin{align*} y&=f(x_1,x_2,x_3) \\\\ &=\\sum_{i=1}&#94;3\\eta_ix_i+\\sum_{i\\leq j}\\eta_{ij}x_ix_j+\\eta_{123}x_1x_2x_3 \\end{align*} 分别取 \\(x_i=1, x_j=x_k=0;x_i=x_j=1/2,x_k=0;x_i=x_j=x_k=1/3\\) ,分别代入单形重心设计的多项式，可得各系数与各响应值的关系。 各系数与各响应值的关系如下： \\begin{equation*} \\begin{cases} \\eta_i&=y_i \\\\ \\eta_{ij}&=2\\big(2&#94;1y_{ij}-1&#94;1(y_i+y_j)\\big) \\\\ \\eta_{ijk}&=3\\big(3&#94;2y_{ijk}-2&#94;2(y_{ij}+y_{ik}+y_{jk})+1&#94;2(y_i+y_j+y_k)\\big) \\end{cases} \\end{equation*} 其实经过推导，可以获得一般公式的，若 \\(S_r=\\{i_1,i_2,\\cdots,i_r\\}\\) 为关于 \\((1,2,\\cdots,p)\\) 的某个 \\(r\\) 元素的子集，则:（公式3) \\begin{equation*} \\eta_{S_r}=r\\Big(\\sum_{t=1}&#94;r(-1)&#94;{r-t}t&#94;{r-1}L_t(S_r)\\Big) \\end{equation*} 其中 ，从 \\(S_r\\) 对应的 \\(r\\) 个分量中取 \\(t\\) 个， \\(L_t(S_r)\\) 表示所有 \\(C_r&#94;t\\) 个分量等比例混料响应的和（简单的说就是 \\(1\\) 到 \\(r\\) 取 \\(t\\) 个的不重复组合）。 下面举例计算 \\(\\eta_{1234}\\) ： 在 \\(\\eta_{1234}\\) 中， \\begin{equation*} \\begin{cases} r& = 4 \\\\ S_4& = \\{i_1,i_2,\\cdots,i_r\\}=\\{1,2,3,4\\} \\\\ L_1(S_4)& = y_1+y_2+y_3+y_4 \\\\ L_2(S_4)& = y_{12}+y_{13}+y_{14}+y_{23}+y_{24}+y_{34} \\\\ L_3(S_4)& = y_{123}+y_{124}+y_{134}+y_{234} \\\\ L_4(S_4)& = y_{1234} \\end{cases} \\end{equation*} 所以根据公式3有： \\begin{equation*} \\begin{split} \\eta_{1234} & = r\\Big(\\sum_{t=1}&#94;r(-1)&#94;{r-t}t&#94;{r-1}L_t(S_r)\\Big) \\\\ & = 4\\Big(\\sum_{t=1}&#94;4(-1)&#94;{4-t}t&#94;{4-1}L_t(S_4)\\Big) \\\\ & = 4\\Big((-1)&#94;{4-1}1&#94;{4-1}L_1(S_4)+(-1)&#94;{4-2}2&#94;{4-1}L_2(S_4)+(-1)&#94;{4-3}3&#94;{4-1}L_3(S_4)+(-1)&#94;{4-4}4&#94;{4-1}L_4(S_4)\\Big) \\\\ & =-4(y_1+y_2+y_3+y_4)+32(y_{12}+y_{13}+y_{14}+y_{23}+y_{24}+y_{34})-108(y_{123}+y_{124}+y_{134}+y_{234})+256y_{1234} \\end{split} \\end{equation*} 再举例计算 \\(\\eta_{23}\\) ： 在 \\(\\eta_{23}\\) 中， \\begin{equation*} \\begin{cases} r& = 2 \\\\ S_2& = \\{i_1,i_2,\\cdots,i_r\\}=\\{2,3\\} \\\\ L_1(S_2)& = y_2+y_3\\\\ L_2(S_2)& = y_{23} \\\\ \\end{cases} \\end{equation*} 所以根据公式3有： \\begin{equation*} \\begin{split} \\eta_{23} & = r\\Big(\\sum_{t=1}&#94;r(-1)&#94;{r-t}t&#94;{r-1}L_t(S_r)\\Big) \\\\ & = 2\\Big(\\sum_{t=1}&#94;2(-1)&#94;{2-t}t&#94;{2-1}L_t(S_2)\\Big) \\\\ & = 2\\Big((-1)&#94;{2-1}1&#94;{2-1}L_1(S_2)+(-1)&#94;{2-2}2&#94;{2-1}L_2(S_2)\\Big) \\\\ & =2\\Big(-(y_2+y_3)+2y_{23}\\Big) \\end{split} \\end{equation*} 单形重心法代码实现 先导入相应的包。 import numpy as np from itertools import chain , combinations 由公式3可知，我们需要生成 \\(S_r\\) ，它是一个不含空集的幂集，简单地，生成一个不含空集的 Power Set ，这里演示 n_point 为对应的 \\(p\\) 。 n_point = ... nums = range ( n_point ) # generate a powerset except zeroset test_points = tuple ( chain . from_iterable ( map ( lambda num : combinations ( nums , num + 1 ), nums ))) 有了 \\(S_r\\) ，我们就可以逐个生成 \\(L_t(S_r)\\) ，及 \\(\\eta_{S_r}\\) ，然后传入各点实测的 \\(y\\) ，即可计算出响应曲面的系数： _response_surface_coef 。 y = np . array ([ ... ]) _response_surface_coef = [] for i , test_point in enumerate ( test_points ): r = len ( test_point ) temp = 0 for j in range ( 1 , r + 1 ): for test_point_pos in combinations ( test_point , j ): t = len ( test_point_pos ) temp += y [ test_points . index ( test_point_pos )] * \\ r * ( - 1 ) ** ( r - t ) * t ** ( r - 1 ) _response_surface_coef . append ( temp ) 有了响应曲面的系数，即可算出每个 \\(\\begin{pmatrix}x_1,\\dots,x_n\\end{pmatrix}\\) 的响应值。 此处输入的是x'，也就是编码矩阵。 prediction = _response_surface_coef . dot ( [ X . take ( test_point_pos , axis = 1 ) . prod ( axis = 1 ) for test_point_pos in test_points ] ) 带下界的设计 由于单形重心要求 \\(0\\leq x_i\\leq 1\\) ，但在实际试验中，很难做到。如混凝土掺合料设计试验中，取煤灰或石粉等为100%时无法获取有效数据。 如上图， \\(a_i\\) 为各成分最小含量，我们将 \\(\\{x'_i\\}\\) 称为自然空间， \\(\\{x_i\\}\\) 称为编码空间（实际值），要在编码空间上进行单形重心设计，必须将其映射到自然空间上（编码值）。 \\begin{equation*} \\begin{cases} 0\\leq x'_i\\leq 1 \\\\ \\sum_{i=1}&#94;pa_i\\leq 1 \\\\ 0\\leq x'_i\\leq x_i\\leq 1 \\end{cases} \\end{equation*} 编码值与实际值可以进行线性变换 \\(\\{x'_i\\}\\leftrightarrow\\{x_i\\}\\) ，由上图可得变换矩阵 \\(M\\) ： \\begin{equation*} M = \\begin{bmatrix} 1+a_1-\\sum_{i=1}&#94;pa_i & a_1 & a_1 & \\dots & a_1 \\\\ a_2 & 1+a_2-\\sum_{i=1}&#94;pa_i & a_1 & \\dots & a_1 \\\\ \\vdots & \\vdots & \\ddots & \\dots &\\vdots \\\\ a_p & a_p & a_p & \\dots & 1+a_p-\\sum_{i=1}&#94;pa_i \\\\ \\end{bmatrix} \\end{equation*} 再通过坐标与自然空间相乘得 \\(x_i\\) （公式4) \\begin{equation*} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_p \\end{pmatrix} = M\\begin{pmatrix} x'_1 \\\\ x'_2 \\\\ \\vdots \\\\ x'_p \\end{pmatrix} \\end{equation*} 实际值与编码值也可以按以下公式进行转换（线性变换化简的公式，虽然文献中用的多，但个人觉得不够直观，不推荐使用）： \\begin{equation*} \\begin{cases} x'_i&=(1-\\sum_{i=1}&#94;pa_i)x_i+a_i \\\\ x_i&=\\frac{x'_i-a_i}{1-\\sum_{i=1}&#94;pa_i} \\end{cases} \\end{equation*} 编码空间上的点 \\(X\\) 为配料的真实比例，而自然空间的点 \\(X'\\) （编码值）则为变换后的符合单纯形设计的比例。 编码空间映射到的自然空间并不是成分均为100%的单纯形，仅仅是概念上的自然空间。故应直接按单纯形重点设计，得到数据之后通过等值线找到自然空间中的点，再通过编码转换得到真实的配比。 带下界的单形重心法代码实现 假设下界为变量 lower_bounds ， \\(lower\\_bounds = [a_1,a_2,\\dots,a_p]\\) ，当 \\(lower\\_bounds = [0,\\dots,0]\\) 时，即是普通的单形重心法。 由公式3生成 \\(S_r\\) n_point = ... nums = range ( n_point ) # generate a powerset except zeroset test_points = tuple ( chain . from_iterable ( map ( lambda num : combinations ( nums , num + 1 ), nums ))) 生成变换矩阵 \\(M\\) ， _M = lower_bounds . repeat ( n_point ) . reshape ( ( n_point , n_point )) \\ - np . eye ( n_point ) \\ - ( 1 - lower_bounds . sum ()) 如前所述，有了 \\(S_r\\) ，然后传入各点实测的 \\(y\\) ，即可计算出响应曲面的系数： _response_surface_coef ，注意，此处不需要转换矩阵 M 。 y = np . array ([ ... ]) _response_surface_coef = [] for i , test_point in enumerate ( test_points ): r = len ( test_point ) temp = 0 for j in range ( 1 , r + 1 ): for test_point_pos in combinations ( test_point , j ): t = len ( test_point_pos ) temp += y [ test_points . index ( test_point_pos )] * \\ r * ( - 1 ) ** ( r - t ) * t ** ( r - 1 ) _response_surface_coef . append ( temp ) 有了响应曲面的系数，即可通过转换矩阵 _M 和真实比例 X 算出每个 \\(\\begin{pmatrix}x'_1,\\dots,x'_n\\end{pmatrix}\\) 的响应值。 此处输入的是X，也就是编码矩阵。 XX = X . dot ( np . linalg . inv ( _M . T )) prediction = _response_surface_coef . dot ( [ XX . take ( test_point_pos , axis = 1 ) . prod ( axis = 1 ) for test_point_pos in test_points ] ) 应用举例说明 这里对一种调料和一种混凝土的带下界约束单形重心试验设计进行了应用的举例。 两个例子均为3成分混料试验，由于公式2、公式3、公式4均是一般情形的公式，可以推广到任意数量成分的混料试验，不赘述。 例1，调料配制 一种调料由三种成分 \\(A、B、C\\) 混合制成 \\(A、B、C\\) 各为味精、盐、五香粉。 \\(a\\geq 0.2,b\\geq 0.4,c\\geq0.2\\) 。求设计方案。 此处可以按公式1采用 \\(M\\{3,2\\}\\) 单形格子设计，本文主要讲单形重心设计，就不按格子设计来了。采用单形重心设计，取点如下图： 根据 \\(a\\geq 0.2,b\\geq 0.4,c\\geq0.2\\) 画出小单形，即黑色小三角，然后根据单形重心设计标出7个重心（红色数字表示） 由公式4列出编码矩阵： \\begin{align*} M &= \\begin{bmatrix} 1+a-(a+b+c) & a & a \\\\ b & 1+b-(a+b+c) & b \\\\ c & c & 1+c-(a+b+c) \\\\ \\end{bmatrix} \\\\ &= \\begin{bmatrix} 0.4 & 0.2 & 0.2 \\\\ 0.4 & 0.6 & 0.4 \\\\ 0.2 & 0.2 & 0.4 \\\\ \\end{bmatrix} \\end{align*} 根据公式2、公式3和 \\(X'*(Z.T)\\) 可轻松列出试验表和试验结果以及口感得分（A*、B*、C*为编码值， 味精_ 、 盐_ 、 五香粉_ 则为实际成分） 试验号 A* B* C* 味精_ 盐_ 五香粉_ 口感 \\(x'_1\\) \\(x'_2\\) \\(x'_3\\) \\(x_1\\) \\(x_2\\) \\(x_3\\) \\(y_1\\) 1 0 0 0.4 0.4 0.2 5 \\(y_2\\) 0 1 0 0.2 0.6 0.2 11 \\(y_3\\) 0 0 1 0.2 0.4 0.4 8 \\(y_{12}\\) 1/2 1/2 0 0.3 0.5 0.2 10 \\(y_{13}\\) 1/2 0 1/2 0.3 0.4 0.3 2 \\(y_{23}\\) 0 1/2 1/2 0.2 0.5 0.3 10 \\(y_{123}\\) 1/3 1/3 1/3 4/15 7/15 4/15 13 将结果和编码值代入公式2得： \\begin{equation*} y=159x'_1x'_2x'_3+8x'_1x'_2-18x'_1x'_3+5x'_1+2x'_2x'_3+11x'_2+8x'_3 \\end{equation*} 作三角坐标图，根据三角坐标系在最大值作图，可得自然空间中 最大值坐标 \\({x'_i}\\) 为： \\begin{equation*} \\begin{pmatrix} x'_1 \\\\ x'_2 \\\\ x'_3\\end{pmatrix}=\\begin{pmatrix}0.26 \\\\ 0.48 \\\\ 0.26 \\end{pmatrix} \\end{equation*} 用编码矩阵转换得真实比例为： \\begin{equation*} \\begin{pmatrix}0.252,0.496,0.252\\end{pmatrix} \\end{equation*} 即，按这个比例配制的调料味道最好。 例2，混凝土强度预测 如上图，混凝土用胶凝材料为水泥，矿粉，煤灰，其中水泥用量在25%以上，求单形重心试验方案。 这是一个约束设计问题，水泥用量25%以上，即 \\(a_1\\geq 0.25, a_2=a_3=0\\) 。 编码矩阵 \\(M\\) 为： \\begin{equation*} \\begin{bmatrix} 1 & 0.25 & 0.25 \\\\ 0 & 0.75 & 0 \\\\ 0 & 0 & 0.75 \\end{bmatrix} \\end{equation*} 标上7个实验点，列出试验表并根据表来做实验得到结果 [2] ： 试验号 A* B* C* 水泥_ 矿粉_ 煤灰_ 强度(MPa) \\(x'_1\\) \\(x'_2\\) \\(x'_3\\) \\(x_1\\) \\(x_2\\) \\(x_3\\) 3d 28d 180d \\(y_1\\) 1 0 0 1 0 0 63.1 88.3 96 \\(y_2\\) 0 1 0 0.25 0.75 0 29.0 56.2 77 \\(y_3\\) 0 0 1 0.25 0 0.75 22.2 53.5 75.4 \\(y_{12}\\) 1/2 1/2 0 0.625 0.375 0 50.6 84.5 90.1 \\(y_{13}\\) 1/2 0 1/2 0.625 0 0.375 44.5 92.3 102 \\(y_{23}\\) 0 1/2 1/2 0.25 0.375 0.375 26.5 62.8 86 \\(y_{123}\\) 1/3 1/3 1/3 0.5 0.25 0.25 40.3 80.5 96.5 将结果和编码值代入公式2得： \\begin{align*} y_{3d}&=63.1x'_1+29.0x'_2+22.2x'_3+18.2x'_1 x'_2+7.4x'_1 x'_3+3.6x'_2 x'_3-28.2x'_1 x'_2 x'_3 \\\\ y_{28d}&=88.3x'_1+56.2x'_2+53.5x'_3+49x'_1 x'_2+85.6x'_1 x'_3+31.8x'_2 x'_3-107.7x'_1 x'_2 x'_3 \\\\ y_{180d}&=96x'_1+77x'_2+75.4x'_3+14.9x'_1 x'_2+65.2x'_1 x'_3+39.2x'_2 x'_3+13.5x'_1 x'_2 x'_3 \\end{align*} 对上面三式作三角坐标图，可以清晰地看出各组分对强度的贡献。从图中求出 \\(x'_1\\) , \\(x'_2\\) , \\(x'_3\\) 坐标，再利用编码矩阵即可换算出实际各组分比例。另外，从3d与28d、180d对比，说明前期是水泥、矿粉对强度贡献大，后期煤灰贡献逐渐超过矿粉。 作图 对组分的单形重心设计可以作图。 [1] 关颖男. 混料试验设计. 上海科学技术出版社, 1990. [2] 孙伟, 严捍东. 复合胶凝材料组成与混凝土抗压强度定量关系研究[J]. 東南大學學報 (自然科學版), 2003, 33(4): 450-453.","tags":"Tech","url":"//blog.laolilin.com/posts/2016/11/implement_simplex_centroid_mix_design_by_python.html","loc":"//blog.laolilin.com/posts/2016/11/implement_simplex_centroid_mix_design_by_python.html"},{"title":"dnspod DDNS 自动更新","text":"前言 由于把 blog 托管在 github pages 和 coding pages ，再加上 我的Raspberry pi 也需要暴露于网络中，所以最好能及时更新域名的IP。 利用 DNSPOD 的 DDNS API ，我们可以轻松在 Raspberry Pi 上实现这个需求。 代码实现 利用 DNSPOD 的 API ，很容易写出自动更新的代码，需要注意的一点是， API 不允许一小时五次都更新同一 IP ，所以代码里考虑到这点，对比二者，如果相同则不进行操作。 login_token 可以从 DNSPOD 获取，按格式把域名和ip填入 data 。 保存如下代码为 /usr/local/sbin/ddns_update.py 。 #!/usr/bin/python # Author: lao # url: http://laolilin.com import socket import urllib.parse import urllib.request import json def initReq ( url , values ): ''' simple request data from url with values ''' data = urllib . parse . urlencode ( values ) . encode () req = urllib . request . Request ( url , data ) try : res = urllib . request . urlopen ( req ) except : raise return res def getIp (): ''' grab the ip of the machine ''' data = initReq ( 'http://ip.taobao.com/service/getIpInfo2.php' ,{ 'ip' : 'myip' }) return json . loads ( data . read () . decode ())[ 'data' ][ 'ip' ] def updateData (): ''' update ip records of data, prepared for update it ''' res = initReq ( url = DomainListUrl , values = loginInfo ) domainIDs = { i [ 'name' ]: i [ 'id' ] for i in json . loads ( res . read () . decode ())[ 'domains' ]} for domain in data : domain [ 'domainID' ] = domainIDs . get ( domain [ 'domain' ]) res = initReq ( url = RecordListUrl , values = { ** loginInfo , ** { 'domain_id' : domain [ 'domainID' ]}}) subdomainInfo = {(( i [ 'name' ], i [ 'line' ]) if i [ 'type' ] == 'A' else ( 'invalid' , 'invalid' )): { 'IP' : i [ 'value' ], 'ID' : i [ 'id' ]} for i in json . loads ( res . read () . decode ())[ 'records' ]} subdomains = domain [ 'subdomains' ] for name in subdomains : subdomains [ name ] . update ( subdomainInfo . get ( name )) ipList = socket . gethostbyname_ex ( subdomains [ name ][ 'hostname' ]) subdomains [ name ][ 'hostIP' ] = ipList [ - 1 ][ - 1 ] def main (): updateData () httpData = [] for domain in data : subdomains = domain [ 'subdomains' ] for subdomain , _ in subdomains . items (): # avoid update too frequenly if _ [ 'IP' ] != _ [ 'hostIP' ]: httpData . append ( { ** loginInfo , ** { 'domain_id' : domain [ 'domainID' ], 'record_id' : _ [ 'ID' ], 'record_line' : subdomain [ 1 ], 'sub_domain' : subdomain [ 0 ], 'value' : _ [ 'hostIP' ] } } ) else : continue for item in httpData : try : initReq ( url = RecordDdnsUrl , values = item ) except : pass DomainListUrl = 'https://dnsapi.cn/Domain.List' RecordListUrl = 'https://dnsapi.cn/Record.List' RecordDdnsUrl = 'https://dnsapi.cn/Record.Ddns' loginInfo = { 'login_token' : '**your login token**' , 'format' : 'json' } data = [ { 'domain' : 'laolilin.com' , 'domainID' : '' , 'subdomains' : {( 'blog' , '默认' ): { 'ID' : '' , 'IP' : '' , 'hostIP' : '' , 'hostname' : 'pages.coding.me' }, ( 'blog' , '国外' ): { 'ID' : '' , 'IP' : '' , 'hostIP' : '' , 'hostname' : '192.30.252.153' }, ( 'pi' , '默认' ): { 'ID' : '' , 'IP' : '' , 'hostIP' : '' , 'hostname' : getIp ()}, } }, ] if __name__ == \"__main__\" : main () 自动更新 由于 systemd 可以轻松实现自动运行脚本，故只需要一个 timer 和一个 service 。 创建 service sudo touch /usr/lib/systemd/system/ddns-update.service 先建立个空文件。 再填入以下内容，意思是用 root 运行 ddns_update.py 。 [Unit] Description=Update ip records After=network.target [Service] Type=simple ExecStart=python /usr/local/sbin/ddns_update.py User=root Group=systemd-journal 创建 timer timer 就是个定时器，和 ddns_update.service 同名, sudo touch /usr/lib/systemd/system/ddns-update.timer 。 再填入以下内容，启动后10秒开始执行，每30分钟运行一次。 [Unit] Description=Update ip records. [Timer] OnBootSec=0.1min OnUnitActiveSec=30min Unit=ddns-update.service [Install] WantedBy=timers.target 启用 很简单，用 sudo systemctl enable ddns-update.timer 即可。","tags":"Tech","url":"//blog.laolilin.com/posts/2016/10/dnspod_ddns_auto_update.html","loc":"//blog.laolilin.com/posts/2016/10/dnspod_ddns_auto_update.html"},{"title":"Raspberry pi 配置","text":"前言 Raspberry pi 是一个ARM开发板，我用的是 Raspberry pi 2 model B 俗称2B版，4核ARM Cortex-A7 CPU（900MHZ），1GB内存。 rpi2B带USB wifi时功耗仅1~5W，很适合用来搭要求不高的家庭长期服务系统，比如本文所述的 dnspod DDNS自动更新 、 内网穿透 、 hostapd配置wifi 、 ResilioSync同步(原BTSync) 、 aria2 下载服务 等，配置好了就不用再管了，做个小玩具挺好。 系统安装 系统我选 Archlinux ，毕竟pc和自己的服务器上长期使用 Archlinux ，再加上好用的滚动更新，有什么理由不在 rpi2B 上装个 Archlinux ？ 具体安装方法 Archlinux ARM 安装指引 进行安装，很简单，不赘述。默认用户名 alarm ，密码同用户名。敢死队长 root 密码为 root 。 系统安装不一定要在linux上，显然可以用VirtualBox里的Linux来安装， 系统恢复 也可以在里面进行恢复。 系统配置 安装完，登录前运行 touch boot/ssh 并 echo hdmi_force_hotplug=1 >> boot/config.txt 在 boot/boot.txt 修改 root 为 ro ，即只读模式，安装 uboot-tools 并执行 ./mkscr 。 同样，在 etc/fstab 中也需要将boot分区变为ro defaults,ro,errors=remount-ro 安装树莓派专用内核 pacman -Syyu linux-raspberrypi4 raspberrypi-firmware 修改etc/fstab 为0p1 修改/boot/cmdline.txt 删除 kgdboc=ttyAMA0,115200 修改/boot/config.txt 增加 hdmi_force_hotplug=1 enable_uart=1 初次使用配置 初始账户和密码均为alarm ssh登录后先 su 到 root ，然后 vi /etc/ssh/sshd_config 加入一行: PermitRootLogin yes ； 重启 sshd systemctl restart sshd ； 从 sshd_config 删除 PermitRootLogin yes ； 修改 pacman 镜像 vi /etc/pacman.d/mirrorlist ： Server = http://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repo 改用户名 按个人习惯，先改掉默认的用户名。 如果你直接用alarm登录，是无法修改用户名的，先用 root 登录。 new_user = lao # change user name usermod -l $new_user -d /home/ $new_user -m alarm # chenge user group groupmod -n $new_user alarm 修改用户密码 passwd lao 。 安装 sudo 先装个 sudo ，不能裸奔。 pacman -S sudo visudo # uncomment the line \"%wheel ALL=(ALL) ALL\" vi /etc/locale.gen # uncomment en_US.UTF-8 UTF-8 locale-gen 时间相关 timedatectl set-ntp true rm /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 然后就可以重启了，最后要安装 lrzsz 和 tmux 。 配置bash 从TLDP上的 .bashrc样例 拿到配置好的 .bashrc 即可。 wget https://gist.github.com/lll9p/a1df902cc68171bb6b3dca31891629c0/raw/4dfdd03af92335f17eec12e0b4b0cd3ce2584eaf/.bash .bashrc 上面的配置很全面了，只需要加上自己的一些，如： # If not running interactively, don't do anything [[ $- ! = *i* ]] && return set editing-mode vi set -o vi export PATH += :/opt/vc/bin export LANG = en_US.UTF-8 启动时检查硬盘 rpi不自带电池，系统所在的MicroSD卡又容易出现问题，所以每次开机都对硬盘自检是最好了。在 /boot/cmdline.txt 中设置系统启动时硬盘只读，进行磁盘检查之后再 mount 到 / 即可。 在 /boot/cmdline.txt 中的 root=/dev/mmcblk0p2 后的 rw 改为 ro 。即： root=/dev/mmcblk0p2 ro rootwait console=ttyAMA0,115200 console=tty1 selinux=0 plymouth.enable=0 smsc95xx.turbo_mode=N dwc_otg.lpm_enable=0 kgdboc=ttyAMA0,115200 elevator=noop 在 /etc/fstab 中，加一行： /dev/mmcblk0p2 / ext4 remount,rw,defaults,noatime 0 1 安装其他\"必备软件\" sudo pacman -S --needed bash-completion bzip2 coreutils dhcpcd dkms dnsmasq dosfstools e2fsprogs findutils gawk gcc gcc-libs gzip hostapd less lrzsz p7zip rp-pppoe sudo sysfsutils tmux unzip vim watchdog wireless_tools wiringpi wpa_supplicant alsa-firmware alsa-utils aria2 cblas dkms dnsmasq hdf5 hdparm lapack moc rng-tools samba wget which wqy-zenhei mldonkey 网络配置 ArchlinuxARM 默认设好了 DHCP ，不需要额外配置，不过 wifi 之类的还是要自己设置的，由于我用的是 RTL8188EUS 芯片的USB网卡，自带驱动无法启动 hostapd ，所以还是需要进行一番安装与设置。 hostapd配置wifi 之前为了启用RTL8188EUS网卡（用 lsusb 命令可以查看），需要下载 jenssegers RTL8188-hostapd 驱动 然后编译。 别一个好办法是下载 lwfinger RTL8188 驱动 ，然后用dkms管理编译和安装，这样可以直接使用Arch库里的hostapd，不过每次内核更新的时候就要再运行一次 sudo dkms install 8188eu/1.0 。 wget https://github.com/lwfinger/rtl8188eu/archive/v4.1.8_9499.zip unzip v4.1.8_9499.zip sudo dkms add ./rtl8188eu sudo dkms build 8188eu/1.0 sudo dkms install 8188eu/1.0 sudo touch \\e tc \\m odprobe.d \\8 188eu.conf sudo echo \"# r8188eu is staging, 8188eu is off-kernel \\n blacklist r8188eu \\n options 8188eu rtw_power_mgnt=0 rtw_enusbss=0\" > \\e tc \\m odprobe.d \\8 188eu.conf 重启后完成驱动安装，接下来要配置 hostapd ，可以直接下载 我的 hostapd 配置 ，存为 /etc/hostapd/hostapd.conf ，修改 wpa_passphrase=PasswordOfLao 中的密码即完成 hostapd 的安装与配置。 以下内容编译自 Linsir的博客 。 dnsmasq 软AP( hostapd )设置好后，我们还需要个DHCP服务器为设备分配IP地址。这里我们选用轻量级的dnsmasq,它还可以提示DNS缓存，非常给力。 pacman -S dnsmasq 后编辑 /etc/dnsmasq.conf ，以下是简单的配置，具体的配置及解释请参考 我的 dnsmasq 配置 。 # 无线网卡的设备名，同 hostapd.conf 保持一致 interface=wlan0 # 监听地址，同你想设置的网关地址 listen-address=192.168.0.1 bind-interfaces # DHCP 分配 IP 的起止段和租约时间 dhcp-range=192.168.0.100,192.168.0.200,12h # 推送给客户端的 DNS 服务器 dhcp-option=6,114.114.114.114,223.5.5.5 iptables 设置流量转发 # 设置 sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # 保存 sudo iptables-save > /etc/iptables/iptables.rules 允许转发 需要启用内核的 IPv4 包转发功能，才能正常访问互联网。 sudo echo \"net.ipv4.ip_forward = 1\" >> /etc/sysctl.d/99-sysctl.conf sudo sysctl -p /etc/sysctl.d/99-sysctl.conf 测试 必须先为无线网卡设置好网关和子网掩码，这样 hostapd 启用后，无线网络才能正确获取到IP地址。 sudo ifconfig wlan0 192.168.0.1 netmask 255.255.255.0 sudo systemctl start iptables sudo systemctl start hostapd sudo systemctl start dnsmasq 现在就可以用手机或者笔记本连接，就能获得地址并能上网了。 开机启动 每次运行 hostapd 之前，都必须运行命令来初始化无线网卡 wlan0 ，很麻烦。如果我们要开机就激活无线网络，就要先用自带的 netctl 来管理，配置 /etc/netctl/wireless-wpa-static ： Interface=wlan0 Connection=ethernet IP=static Address='192.168.0.1/24' #Gateway='192.168.0.1' SkipNoCarrier=yes ExecUpPost='iptables-restore < /etc/iptables/iptables.rules &&echo 1 >/proc/sys/net/ipv4/ip_forward' 设置开机启动： sudo netctl enable wireless-wpa-static sudo systemctl enable iptables hostapd dnsmasq PPPOE 我的 rpi 是连路由的，倒不用拨号，若是不用路由，就需要 pppoe 拨号了。 sudo pacman -S rp-pppoe sudo pppoe-setup # 设置 拨号帐户、密码等 sudo systemctl enable adsl iptables 我们需要再次配置 iptables，让网络流量得以穿透 PPPOE 隧道。 sudo iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE sudo iptables-save > /etc/iptables/iptables.rules 最后重启，一个无线路由器就成功了。Enjoy it. dnspod DDNS自动更新 请参考 ddns自动更新 。 内网穿透 有时候公司内网需要在外访问，这时最好用的就是内网穿透工具了，这里推荐 frp ， ngrok 也可用 。 frp frp 是一个开源的网罗穿透工具，下载 linux_arm 的release即可。 ngrok ngrok 是一个网络穿透的服务， ngrok 2 是收费服务，而 ngrok 1 则是开源的，我们可以使用 ngrok 1 。 ngrok 需要编译，过程如下： git clone https://github.com/inconshreveable/ngrok.git ngrok cd ngrok vim src/ngrok/log/logger.go # 第五行import中的 log 包，改为：log \"github.com/keepeye/log4go\" # 为根域名生成证书 export NGROK_DOMAIN=\"laolilin.com\" openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN\" -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN\" -out device.csr openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 yes | cp rootCA.pem assets/client/tls/ngrokroot.crt yes | cp device.crt assets/server/tls/snakeoil.crt yes | cp device.key assets/server/tls/snakeoil.key # 指定编译的环境变量: linux GOOS=linux GOARCH=amd64 make release-server release-client # Raspberry pi GOOS=linux GOARCH=arm make release-server release-client # windows GOOS=windows GOARCH=386 make release-server release-client 编译完成后在 ./bin/ 下找到 ngrokd 及 ngrok 。 sudo cp ./bin/arm/{ngrokd,snakeoil.crt,snakeoil.key} /usr/local/sbin/ ，然后开一个专用的ngrok用户，及专用 pid 文件。 # add ngrok user without home dir and cannot login sudo useradd --shell /bin/nologin --no-create-home --user-group ngrok # create an empty ngrok directory on /var/run using systemd or ngrok cannot create pid file sudo echo 'd /var/run/rslsync 0755 ngrok ngrok' > /usr/lib/tmpfiles.d/ngrok.conf 另存下面的代码为 /usr/lib/systemd/system/ngrok-server.service ，并启用之： sudo systemctl enable ngrok-server 。 [Service] Type=simple User=ngrok Group=ngrok ExecStart=/usr/local/sbin/ngrokd -log-level=\"ERROR\" -tlsKey=/usr/local/sbin/snakeoil.key -tlsCrt=/usr/local/sbin/snakeoil.crt -domain=laolilin.com -httpAddr=:8888 -httpsAddr=:8081 PIDFile=/var/run/ngrok/ngrokd.pid Restart=always [Install] WantedBy=multi-user.target 把以下内容存为 ngrok.conf 。 server_addr: \"rpi.laolilin.com:4443\" trust_host_root_certs: false tunnels: jupyter: remote_port: 8889 proto: tcp: \"8889\" rdp: remote_port: 9000 proto: tcp: \"3389\" 最后，在内网电脑上执行命令： ngrok.exe -config=ngrok.conf start jupyter rdp （或放入 计划任务 中），即可在外网访问内网的 远程桌面 及 jupyter notebook 。 系统备份与恢复 辛辛苦苦安装并配置好的系统因各种原因（比如 我删过/ ）丢失或损坏，如果此时有一份备份，那是最好不过的了。 系统与配置备份 在这里我用 tar 命令来按日备份系统，并排除掉一些动态的系统目录。 当然了有时候并不用备份整个系统，只要备份修改过的配置文件即可，毕竟全系统备份很耗时。 备份项目 全系统 仅配置 耗时 2.5min 20second 在 .bashrc 下加两句 alias 即可。 alias backup_system = \"sudo tar --exclude=/{dev,lost+found,mnt,proc,run,sys,tmp,var/lib/pacman} --exclude=/home/python/{venv,PyNote,.cache,.viminfo,.theano,.ipython,.local} --exclude=/home/user/{.cache,.vimtmp,moc,.config/cmus} --exclude=/home/git/repos --xattrs -cpzf /mnt/MHDD/system_backup/backup-`date +%Y-%m-%d`.tgz /\" alias backup_system_config = \"sudo tar --xattrs -cpzf /mnt/MHDD/system_backup/backup-config-`date +%Y-%m-%d`.tgz \\ /boot/{cmdline.txt,config.txt} \\ /etc/{conf.d/,hostapd/,iptables/,modprobe.d/,modules-load.d/,netctl/{pppoe,wireless-wpa-static},pacman.d/mirrorlist,ppp/{ip-up.d/01-dynamicIP.sh,chap-secrets,pap-secrets,pppoe.conf},rslsync/,ssh/,systemd/user/aria2.service,sysctl.d/,samba/,wpa_supplicant/,dhcpcd.conf,dhcpcd.duid,dnsmasq.conf,fstab,group,group-,gshadow,gshadow-,hostname,locale.gen,pacman.conf,passwd,passwd-,resolv.conf,shadow,shadow-,sudoers,watchdog.conf} \\ /home/{user/{.config/aria2,.ssh,.vim,.bashrc,.toprc,.vimrc},git/{.ssh,.bashrc},python/{.config/matplotlib/,.jupyter/,.bashrc}} \\ /root/{.gnupg/,.bashrc} \\ /usr/{lib/{systemd/system/{hdparm.service,rslsync.service,ddns-update.service,ddns-update.timer,dnsmasq.service,hostapd.service,jupyter-notebook.service,ngrok-server.service,watchdog.service},tmpfiles.d/{rslsync.conf,jupyter.conf,ngrok.conf}},local/sbin/{ddns_dnspod.py,forward-ssh.sh,ngrokd,snakeoil.crt,snakeoil.key,start-jupyter-notebook}}\" 系统恢复 解压很简单，只要一行即可，需要注意的是，若要还原整个系统，需要把 /boot mount进\"根目录里\"。 mkdir boot root sudo mount /dev/sdx1 root sudo mount /dev/sdx2 root/boot tar xvpfz backup.tgz -C root ResilioSync同步(原BTSync) ResilioSync （以下简称rslsync），也就是改名前的BTSync，基于BitTorrent协议的文件分享系统。可以用pi+rslsync来做同步服务器，我把PC上的Dropbox文件夹放rslsync中同步，实现双重备份，经一年多的使用，挺稳定的。 下载resiliosync并解压 在Pi上插一个1.5T的移动硬盘，以下步骤可使用它来做Resiliosync的硬盘。 # download & extract Resiliosync wget https://download-cdn.resilio.com/stable/linux-armhf/resilio-sync_armhf.tar.gz tar xvzf resilio-sync_armhf.tar.gz sudo mv rslsync /usr/local/sbin # mount the mobile hard disk drive # replace sdx with your real device name sudo mount /dev/sdx /mnt/MHDD 创建rslsync用户及相关配置 开一个专用的rslsync用户对于系统控制很有好处，可以将rslsync与其他用户隔离开来，下面的代码将创建一个 无家目录 且 不能登录 的 rslsync 用户。 # add rslsync user without home dir and cannot login sudo useradd --shell /bin/nologin --no-create-home --user-group rslsync # create an empty rslsync directory on /var/run using systemd or rslsync cannot create pid file echo 'd /var/run/rslsync 0755 rslsync rslsync' | sudo tee /usr/lib/tmpfiles.d/rslsync.conf # make config file path and dump sample config to it sudo mkdir /etc/rslsync/ rslsync --dump-sample-config | sudo tee /etc/rslsync/config.json 编辑 config.json ,把 \"storage_path\" 设成 \"/mnt/MHDD/.sync\" ， \"pid_file\" 设为 \"/var/run/rslsync/rslsync.pid\" 。 开机启动rslsync，编辑 /usr/lib/systemd/system/rslsync.service ，为方便其他用户能读写同步的文件，需要对rslsync的umask进行设置 0002 。 [ Unit ] Description = Resilio Sync After = mnt-MHDD.mount After = systemd-fsck@.service [ Service ] Type = forking User = rslsync Group = rslsync UMask = 0002 PIDFile = /var/run/rslsync/rslsync.pid ExecStart = /usr/local/sbin/rslsync --config /etc/rslsync/config.json Restart = on-abort [ Install ] WantedBy = multi-user.target 然后 sudo systemctl enable rslsync 即可。 aria2 下载服务 安装 aria2 ： 直接从 pacman 安装即可，顺手创建配置文件。 sudo pacman -S aria2 mkdir -p .config/aria2 && cd $_ touch session.lock aria2.conf 编辑 aria2.conf ，输入以下配置，注意把 MYSECRET 改成自己的token，以后在 百度网盘导出 及 迅雷离线导出 里，设置jsonrpc为 http://token:MYSECRET@aria2server.com:6800/jsonrpc` 即可顺利使用。 # 基本配置 # 下载目录 dir=/mnt/DISKOFLAO/Downloads # 下载从这个文件中找到的urls, 需自己建立这个文件 # touch /home/pi/.aria2/aria2.session input-file=/home/lao/.config/aria2/session.lock # 最大同时下载任务数，默认 5 #max-concurrent-downloads=5 # 断点续传，只适用于 HTTP(S)/FTP continue=true log-level=error # HTTP/FTP 配置 # 关闭连接如果下载速度等于或低于这个值，默认 0 #lowest-speed-limit=0 # 对于每个下载在同一个服务器上的连接数，默认 1 max-connection-per-server=5 # 每个文件最小分片大小，例如文件 20M，设置 size 为 10M, 则用2个连接下载，默认 20M #min-split-size=10M # 下载一个文件的连接数，默认 5 #split=5 # BT 特殊配置 # 启用本地节点查找，默认 false bt-enable-lpd=true # 指定最大文件数对于每个 bt 下载，默认 100 #bt-max-open-files=100 # 单种子最大连接数，默认 55 #bt-max-peers=55 # 设置最低的加密级别，可选全连接加密 arc4，默认是头加密 plain #bt-min-crypto-level=plain # 总是使用 obfuscation handshake，防迅雷必备，默认 false bt-require-crypto=true # 如果下载的是种子文件则自动解析并下载，默认 true #follow-torrent=true # 为 BT 下载设置 TCP 端口号，确保开放这些端口，默认 6881-6999 listen-port=65298 #Set UDP listening port used by DHT(IPv4, IPv6) and UDP tracker dht-listen-port=65298 # 整体上传速度限制，0 表示不限制，默认 0 #max-overall-upload-limit=0 # 每个下载上传速度限制，默认 0 #max-upload-limit=0 # 种子分享率大于1, 则停止做种，默认 1.0 #seed-ratio=1 # 做种时间大于2小时，则停止做种 seed-time=120 # RPC 配置 # 开启 JSON-RPC/XML-RPC 服务，默认 false enable-rpc=true # 允许所有来源，web 界面跨域权限需要，默认 false rpc-allow-origin-all=true # 允许外部访问，默认 false rpc-listen-all=true # rpc 端口，默认 6800 rpc-listen-port=6800 # 设置最大的 JSON-RPC/XML-RPC 请求大小，默认 2M #rpc-max-request-size=2M # rpc 密码，可不设置 #rpc-passwd=raspberry # 做种时间大于2小时，则停止做种 seed-time=120 # RPC 配置 # 开启 JSON-RPC/XML-RPC 服务，默认 false enable-rpc=true # 允许所有来源，web 界面跨域权限需要，默认 false rpc-allow-origin-all=true # 允许外部访问，默认 false rpc-listen-all=true # rpc 端口，默认 6800rpc-listen-port=6800 # 设置最大的 JSON-RPC/XML-RPC 请求大小，默认 2M #rpc-max-request-size=2M # rpc 密码，可不设置 #rpc-passwd=raspberry # rpc 用户名，可不设置 #rpc-user=aria2pi rpc-secret=MYSECRET # 高级配置 # This is useful if you have to use broken DNS and # want to avoid terribly slow AAAA record lookup. # 默认 false disable-ipv6=true # 指定文件分配方法，预分配能有效降低文件碎片，提高磁盘性能，缺点是预分配时间稍长 # 如果使用新的文件系统，例如 ext4 (with extents support), btrfs, xfs or NTFS(MinGW build only), falloc 是最好的选择 # 如果设置为 none，那么不预先分配文件空间，默认 prealloc file-allocation=prealloc # 整体下载速度限制，默认 0 #max-overall-download-limit=0 # 每个下载下载速度限制，默认 0 #max-download-limit=0 # 保存错误或者未完成的下载到这个文件 # 和基本配置中的 input-file 一起使用，那么重启后仍可继续下载 save-session=/home/lao/.config/aria2/session.lock # 每5分钟自动保存错误或未完成的下载，如果为 0, 只有 aria2 正常退出才回保存，默认 0 save-session-interval=300 # 若要用于 PT 下载，需另外的配置，这里没写 开机启动 aria2 开机启动很简单，把以下代码存为 /etc/systemd/user/aria2.service ，然后 systemctl enable aria2.service --user ，即可。 [Unit] Description=Aria2 Service After=mnt-MHDD.mount After=systemd-fsck@.service After=network.target [Service] Type=simple User=lao Group=lao UMask=0002 PIDFile=/home/lao/.config/aria2/aria2.pid ExecStart=/usr/bin/aria2c --check-certificate=false --enable-rpc=true --rpc-listen-all=true --rpc-allow-origin-all=true --rpc-secret=passwd --save-session /home/lao/.config/aria2/session.lock --input-file /home/lao/.config/aria2/session.lock --conf-path=/home/lao/.config/aria2/aria2.conf Restart=on-abort [Install] WantedBy=multi-user.target mldonkey 安装 samba 安装 smbpasswd -a lao","tags":"Tech","url":"//blog.laolilin.com/posts/2016/10/config_raspberry_pi.html","loc":"//blog.laolilin.com/posts/2016/10/config_raspberry_pi.html"},{"title":"Python数据分析-安装与配置","text":"前言 本文针对 python3.5 的数据分析需求进行配置，尽量满足分析及学习的需求（本人的）。 创建 venv 环境 venv 是 python3.4 以上的版本自带的功能，之前的版本需要安装 virtualenv 。它可以将工作环境及系统的python环境隔离开来，在这个环境下工作很方便，安装包也不需要 root权限 。 # 一条命令完成venv的创建 python -m venv venvoflao # 进入venv source ./venvoflao/bin/activate # 退出venv deactivate 添加以下代码到 ~/.bashrc ，1.主要是自动更新全部包的命令，这样就可以通过 pip_update 来一键更新所有库；2.后面三行是编译 numpy 和 scipy 的必须品： LAPACK 、 BLAS ：先安装好 LAPACK 和 BLAS 然后添加后三行到 ~.bashrc ，然后 source .bashrc 生效。 alias pip_update=\"pip list --outdated | grep --invert-match '&#94;\\-e' | cut --delimiter ' ' --fields 1 | xargs --max-args 1 pip install --upgrade --trusted-host pypi.douban.com\" export LAPACK=/usr/lib/liblapack.so #export ATLAS=/usr/lib/libatlas.so export BLAS=/usr/lib/libblas.so 基本Python库安装 以下的操作都是在 venv 下进行的。 以下代码安装常用的机器学习的库， numpy 和 scipy 编译需要较长时间，耐心等待即可。 pip install numpy, pandas, scipy, sympy, \\ matplotlib, seaborn, plotly, networkx, Pillow, \\ scikit-learn, scikit-image, Theano, Keras, treeinterpreter, \\ notebook, qtconsole, \\ jupyter-contrib-nbextensions, jupyter-nbextensions-configurator, \\ requests, beautifulsoup4, \\ openpyxl, xlrd, xlwt, XlsxWriter matplotlib 中文配置 matplotlib 是一个很常用的画图库，可惜对中文支持不好，其实只要添加中文字体并稍微设置一下即可解决。 安装 文泉驿微米黑 字体， 再 touch .config/matplotlib/matplotlibrc 再添加以下几行到里面即可。 backend : TkAgg font.family : sans-serif font.sans-serif : WenQuanYi Micro Hei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif axes.unicode_minus : True figure.dpi : 96 jupyter notebook 配置 jupyter notebook 是一个很方便的工具，可以在上面直接运行、调试代码，基本上写好之后稍微改下就成了一篇挺好的笔记了，可以导出为 pdf 、 html 等格式（需要安装 pandoc ）。 生成配置文件： jupyter notebook --generate-config 并修改 ~/.jupyter/jupyter_notebook_config.py 下面相应的几行。 c = get_config () c . NotebookApp . notebook_dir = '/home/lao/Notebook' c . NotebookApp . enable_mathjax = True 完成 nbextensions 的安装： jupyter nbextensions_configurator enable jupyter contrib nbextension install --user","tags":"Tech","url":"//blog.laolilin.com/posts/2016/09/python-install-config-for-data-analysis.html","loc":"//blog.laolilin.com/posts/2016/09/python-install-config-for-data-analysis.html"},{"title":"reStructuredText 笔记","text":"Via reStructuredText 笔记 行内标记 例子 效果 备注 *重点* 重点 显示为斜体 **强调** 强调 显示为粗体 `解释文本` 解释 文本 <cite>文本</cite> 因设备而异 ``行 内 字 面`` 行 内 字 面 显示为等宽文本，保留空格，不保留断行 引用_ .. _引用: imtho.com 引用 简单的、一个词的、不带空格的超链接 `短语 引用`_ .. _`短语 引用`: imtho.com 短语 引用 带空格或标点的超链接 匿名__ __ 引用_ 匿名 重用链接 _`行内交叉引用` 行内交叉引用 行内交叉引用,给指定文本一个id 替换参考 见 替换参考 可以是文字，图像，链接或上述及其他的组合 脚注 [1]_ 脚注 [1] 引注 [CIT2002]_ 引注 [CIT2002] http://python.org http://python.org 单独的链接 替换参考 |替换参考| ，可用的替换 directive 有 image 和 replace， 如： |替换参考| .. |替换参考| image :: https://cdn.v2ex.co/site/logo@2x.png?m=1346064962 [1] 这是一个脚注 [CIT2002] 这是一个引注 行内标记分隔符 星号*、反引号`、水平线、下划线_、为行内分隔符，要显示它们，可用转义或双反引号（ \\* 及 ``*`` ） 行内标记必须为 text block 、其之前为空格或以下字符之一 '\"([{< 。 开始字符之后必须紧跟非空格，如 **强调** 是对的，而 ** 强调** 是错的。 结束字符之前必须为非空格。 结束字符必须结束一个块（之后为文档尾或空行），或以空格或以下字符之一结尾 '\".,:;!?-)]}/\\> 。 开始字符之前若为 '\"([{< 之一,则不能以 '\")]}> 结尾。 开始字符与结束字符之间必须有一个字符。 开始字符与结束字符之前若为转义反斜杠，则整个行内标志不会被识别，除了 行内字面量 。 反斜杠转义 原始 rST 效果 \\``用`` \"\\\\\" \\*转义* ``用`` \"\\\" *转义* Section结构 原始 rST 效果 标题可以用以下字符之一来表示： =-`:'\"~&#94;_*+#<> 如本文所示 段落 以空行分隔的字符串。 无序列表 以-、*、+开头，如： - 这是 - 一个 - 无序列表 这是 一个 无序列表 有序列表 以#、数字、字母、i,I开头，开始字符可带.及)，如： i. 这是 #) 嵌套 #) 列表 #. 一个 i. 也是 #. 嵌套 #. 列表 #. 有序列表 这是 嵌套 列表 一个 也是 嵌套 列表 有序列表 定义列表 以词为开头的列表，如： 定义列表 以词开头的列表 ReST reStructuredText 定义列表 以词开头的列表 ReST reStructuredText 区域列表 :作者: 某某 毕业于某某大学 :版本: 1.0 作者: 某某 毕业于某某大学 版本: 1.0 选项列表 选项和描述之间必须间隔两个空格以上，如： -a all -f file 读入文件 --file=file 读入一个文件 /f MS命令行 -a all -f file 读入文件 --file= file 读入一个文件 /f MS命令行 字面量块 字面量块以 \"::\" 开始 :: 空格、新行、空行及::之后的所有字符都以字面量显示。 符号 ``::`` 必须在空行行首，或一段的结尾 :: 真的很方便啊！ 在字面量块中使用单行引用:: > 这是一个 > 单行引用 >> per-line quoting 字面量块以 \"::\" 开始,前后应有空行 空格、新行、空行及::之后的所有字符都以字面量显示。 符号 :: 必须在空行行首，或一段的结尾: 真的很方便啊！ 在字面量块中使用单行引用: > 这是一个 > 单行引用 >> per-line quoting 行块 行块以\"| \"在行首开头。 |这是 |行块 |很好用 行块以\"| \"在行首开头。 这是 行块 很好用 块引用 一个块引用 只需要 缩进 及嵌套 缩进 一个块引用 只需要 缩进 及嵌套 缩进 Doctest块 >>> print('这是一个 Doctest 块') >>> import time >>> print('这是一个 Doctest 块') >>> import time 表格 ReST有两种表格： Grid表格： +------------+------------+-----------+ | Header 1 | Header 2 | Header 3 | +============+============+===========+ | body row 1 | column 2 | column 3 | +------------+------------+-----------+ | body row 2 | Cells may span columns.| +------------+------------+-----------+ | body row 3 | Cells may | - Cells | +------------+------------+-----------+ | body row 4 | | - blocks. | +------------+------------+-----------+ Header 1 Header 2 Header 3 body row 1 column 2 column 3 body row 2 Cells may span columns. body row 3 Cells may Cells body row 4 blocks. 简单表格： ===== ===== ====== Inputs Output ------------ ------ A B A or B ===== ===== ====== False False False True False True False True True True True True ===== ===== ====== Inputs Output A B A or B False False False True False True False True True True True True 分隔线 ---- 分隔线，以4个及以上的\"-\"表示 一条 分隔线，以4个及以上的\"-\"表示 显式标记 脚注 这是一个脚注 [#]_ 。或用\\* [*]_ ，\\#后可加上字符串 [#标识1]_ 用来标识 [#标识2]_ ，亦可用直接数字 [7]_ 。 .. [#] 自动脚注，注意 ``] `` 后没有``_``。 .. [*] 星号脚注。 .. [#标识1] 自动标识1。 .. [#标识2] 自动标识2。 .. [7] _ 数字标识。 这是一个脚注 [2] 。或用* [*] ，#后可加上字符串 [3] 用来标识 [4] ，亦可用直接数字 [7] 。 [2] 自动脚注，注意 ] 后没有``_``。 [*] 星号脚注。 [3] 自动标识1。 [4] 自动标识2。 [7] 数字标识。 引用 一个引用出自 [某文]_ ，还可以出自 某文_ 。 .. [某文] 这里是某文 一个引用出自 [某文] ，还可以出自 某文 。 [某文] 这里是某文 超链接 外部链接，如 Python官网_ ，亦可在行内写出 `Python官网 <https://python.org> `_ 。 .. _Python官网: https://python.org 内部链接，如 此处_ 。 .. _此处: 此处是内部链接一例子。 间接链接，如： 我爱 Python_ , `官网在此`__ 。 .. _Python: https://python.org __ Python_ 隐式链接，如：我要链接到 `显式标记`_ 。 外部链接，如 Python官网 ，亦可在行内写出 Python官网 。 内部链接，如 此处 。 此处是内部链接一例子。 间接链接，如： 我爱 Python , 官网在此 。 隐式链接，如：我要链接到 显式标记 。 指令 见 reStructuredText Directives 。 图片： .. image :: http://docutils.sourceforge.net/docs/user/rst/images/ball1.gif :alt: 一个图片 数学公式： 行内公式： :math: `A_\\text{c} = (\\pi/4) d&#94;2` . 整行公式 .. math :: \\alpha{}_t(i) = P(O_1, O_2, … O_t, q_t = S_i \\lambda{}) 代码： .. code-block :: python # python 代码 def print_hello (): print ( 'Hello, World!' ) 图片： 数学公式： 行内公式： \\(A_\\text{c} = (\\pi/4) d&#94;2\\) . 整行公式 \\begin{equation*} \\alpha{}_t(i) = P(O_1, O_2, \\ldots O_t, q_t = S_i \\lambda{}) \\end{equation*} 代码: # python 代码 def print_hello (): print ( 'Hello, World!' ) 替换引用和定义 此 |生物危害| 标志用在医用废物回收箱中。 .. |生物危害| image :: http://docutils.sourceforge.net/docs/user/rst/images/biohazard.png 还可以构造任意结构，如：我想在新标签页打开 |Python官网|。 .. |Python官网| raw :: html <a href=\"https://python.org\" target=\"_blank\">Python的官网</a> 此 标志用在医用废物回收箱中。 我想在新标签页打开 Python的官网 。 评论 .. 任何以显式标记开始 但没有用任何以上的语法 的文本，就是评论。 空评论： .. 就是\"``..``\"前后都是空行。 空评论： 就是\" .. \"前后都是空行。","tags":"Tech","url":"//blog.laolilin.com/posts/2016/08/reStructuredText-notes.html","loc":"//blog.laolilin.com/posts/2016/08/reStructuredText-notes.html"}]};